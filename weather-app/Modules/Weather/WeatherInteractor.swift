//
//  WeatherInteractor.swift
//  weather-app
//
//  Created Ming Chu on 20/11/2019.
//  Copyright © 2019 vegantell. All rights reserved.
//
//  Template generated by Juanpe Catalán @JuanpeCMiOS
//

import UIKit
import CoreLocation
import RxSwift
import RxCocoa
import RxCoreLocation

class WeatherInteractor: WeatherInteractorInputProtocol {

    weak var presenter: WeatherInteractorOutputProtocol?

    private let locationManager = CLLocationManager()
    private let disposeBag = DisposeBag()

    private (set) var latestLocation: CLLocation?
    private (set) var locationAuthorized: Bool = false
    private (set) var locationAuthorizationStatus: CLAuthorizationStatus?

    init() {
        self.initLocationService()
    }

    func fetchCurrentWeather(queryType: QueryType) {
        // get api from WebService

        //api.openweathermap.org/data/2.5/weather?q={city name}
        //api.openweathermap.org/data/2.5/weather?zip={zip code}
        //api.openweathermap.org/data/2.5/weather?lat={lat}&lon={lon}

        SearchHistoryManager.shared.insertRecord(searchRecord: queryType.createSearchRecord())
        WebServiceManager.shared.request(params: queryType.params, completion: handler)
    }

    private var handler: WebServiceCompletionHandler<WeatherResponse> {
        return { [weak self] (response, error) in
            if let error = error {
                self?.presenter?.fetchCurrentWeatherDidFailed(error: error)
            } else if let response = response {
                self?.presenter?.fetchCurrentWeatherDidSuccess(weatherResponse: response)
            }
        }
    }

    private func initLocationService() {
        locationManager.requestWhenInUseAuthorization()
        locationManager.startUpdatingLocation()

        locationManager.rx.location
            .subscribe(onNext: { [weak self] location in
                guard let location = location else { return }
                self?.latestLocation = location
            })
            .disposed(by: self.disposeBag)

        locationManager.rx.didUpdateLocations
            .subscribe(onNext: { [weak self] _, locations in
                guard !locations.isEmpty, let currentLocation = locations.last else { return }
                self?.latestLocation = currentLocation
            })
            .disposed(by: self.disposeBag)

        locationManager.rx.didChangeAuthorization
            .subscribe(onNext: { [weak self] _, status in
                guard let `self` = self else { return }
                self.locationAuthorizationStatus = status
                self.locationAuthorized = [.authorizedAlways, .authorizedWhenInUse].contains(status)

                switch status {
                case .denied:
                    logger.debug("Authorization denied")
                case .notDetermined:
                    logger.debug("Authorization: not determined")
                case .restricted:
                    logger.debug("Authorization: restricted")
                case .authorizedAlways, .authorizedWhenInUse:
                    logger.debug("All good fire request")
                default:
                    break
                }
            })
            .disposed(by: self.disposeBag)
    }
}
